***꼭 교재의 연습문제, 핵심 보기!!!! / <=주의 / key:array[mid]***
	[9주차]
1. 스택: LIFO top init=-1 배열로 구성
2. 중위표기->후위표기 변환: 새 연산 우선순위가 top보다 높으면 push 아니면 top의 연산자를 전부 pop 숫자는 출력
	ㄴ괄호가 있다면 (는 무조건 push, )는 (나올때까지 push
3. 후위표기 연산: 피연산자는 push, 연산자는 pop2개해서 계산하고 결과를 push

	[10~11주차]
0. 구조체 별칭 typedef struct node{}NODE_TYPE; 이를 "형 정의문"이라고 한다.
1. 자기참조 구조체
typedef struct self_ex *self_expointer; 구조체 선언도 전에 다음의 타입의 포인터를 self_expointer로 선언한다는 뜻.
struct self_ex{
    long id;
    self_ex_pointer;
};
2. ptr=(self_expointer)malloc(sizeof(struct self_ex);처럼 포인터로 바꾸지만 메모리 할당 시 사이즈는 일반 구조체 크기.
3. 트리 문자열 malloc하고 문자열을 담을 때, 복사는 strcpy로하지만 구조체 내부 char*역시 (char*)malloc(strlen(wbuf)+1)로 할당후 복사해줘야 한다.
4. int insert_node(NODETYPE* root, char* str)는 tptr로 빈공간찾고 malloc존나하다가 before 왼쪽이나 오른쪽에 달기
NODETYPE* search(NODETYPE* root, char* key)는 그냥 tptr하나 달고 while로 와리가리하다 찾으면 리턴
void inorder(NODETYPE *root)는 그냥 notnull이면 재귀출력재귀
5. 트리의 깊이는 0부터 시작
int maxDepth(TreeNode* root){
	if(root==NULL)
		return 0;
	return (1+maxDepth(root->left)> (1+maxDepth(root->right) ? (1+maxDepth(root->left) : (1+maxDepth(root->right)
}

	[10주차 보충자료]
1. 파일 입출력 열기_File *db=fopen(argv[1], "r"); 읽기_while(fscanf(db, "%s %u", temp[i].name, temp[i].id)!=EOF){i++} 읽은크기_dnum=i 쓰기_fprintf(out, "%ld\t%s", s[j].id, s[i].name);
2. 파일 입력받아 구조체 형식의 연결리스트에 넣기_파일 읽은다음 before세팅만 if(ptr)에 따라 해주고 malloc.
	ㄴ이거 예제가 변수를 조금 햇갈리게 썼는데, temp malloc해서 fscanf로 읽은 뒤에 before로 temp를 등록하고 새로운 temp를 미리 malloc해두는 순서구조. 마지막에 before->next=NULL주의

	[12주차]_정렬되는 순서를 그릴 수 있어야 한다. 내림차순은 부호 방향만 바꿈
1. 버블정렬: 정렬되는 순서는 그냥 2개간격으로 비교하는 느낌. 최적화를 위해 flag를 두어 내부 loop에서 변경없으면 끝내게 while조건에 &&로 추가 가능
2. 삽입정렬: 2번째 데이터부터 시작하는 i를 정렬되어 있는 앞부분에 들어갈자리를 찾아 swap하는 것. 구현은 i를 저장해두고 위치를 찾을 때 까지 shift하다가 위치를 찾으면 거기에 저장값을 넣음. 
	ㄴ슬라이드 8의 코드 앞에서부터 버블하는거고, 정렬 완료 되었어도 한번 더 돌아야 완료임을 알 수 있는거랑 그러면서 i--되서 i==5 flag=0임.

	[13주차]
**1. 퀵정렬: C.A.R.Hoare가 만듬. pivot을 중심으로 pivot왼쪽에는 작은값, 우측에는 큰값을 가지게 분할한다.
	ㄴleft<right일 때로 전체를 감싸고, i=left, j=right+1을 해서 범위를 양쪽에서 좁혀가면서 피벗기준 정렬할거임. while(i<right)일때 do i++ while(a[i]<pivot && i<right)과 do j-- while(a[j]>pivot && j>left)를 수행함. 그러면 양쪽에서 어긋나는거 하나씩을 가져왔을거임. if(i<j)확린 한번만 더 해주고 swap을 수행. 전체 while이 끝나면 pivot을 옮겨줘야하기에 if(j!=left)일 때 left와 swap해준 뒤 재귀로 quick_sort(a, left, j-1) quick_sort(a, j+1, right)해주면 됨.

void quick_sort(int a[], int left, int right){
	int pivot, i, j, tmp;
	
	if(left<right){
		i=left;
		j=right+1;
		pivot=a[left];
		
		while(i<j){
			do 
				i++;
			while(a[i]<pivot && i<right);
			
			do
				j--;
			while(a[j]>pivot && j>left);
			
			if(i<j){
				tmp=a[i];
				a[i]=a[j];
				a[j]=tmp;
			}
		}
		
		if(j!=left){
			tmp=a[j];
			a[j]=a[left];
			a[left]=tmp;
		}
		
		quick_sort(a, left, j-1);
		quick_sort(a, j+1, right);
	}
}

2. 이진합병정렬: 정렬된 두 데이터 집합을 하나의 정렬된 데이터 집합으로 합병. i, j, k를 이용해서 읽으면서 저장'
int merge(int a1[], int a2[], int a[], int n1, int n2){
    int i=0, j=0, k=0;

    while(i<n1 && j<n2){
        if(a1[i]<=a2[j})
            a[k++]=a1[i++];
        else if(a1[i]>a2[j])
            a[k++]=a2[j++];
    }
    if(i==n1)
        while(j<n2)
            a[k++]=a2[j++];
    else
        while(i<n1)
            a[k++]=a1[i++];
    return k;//전체 길이(n1+n2)를 리턴
}

	[복습]
1. & 주소연산자 / * 역참조 연산자(간접지시)
2. 예제2) 현재 fp는 할당되지 않은 공간이기에 쓰레기 값임. 이 상태로 실행하려면 malloc을 사용하거나 아래의 순서를 바꿔야함. 
3. 함수에서 포인터 조작.
4. 찌끄래시 소숫점 함수 flaot sum=0.0하고 sum+=(data[i]-int(data[i]))
5. Loop Control Variable 순차리스트가 아닌 연결리스트 필요: 가변적인 크기, 중간에 삽입, 중간에 데이터 삭제. 데이터의 크기와 처리가 동적인 환경에서는 필요할 때 마다 실행시간에 생성해서 연결하는 구조가 적합하다.
6. 연결리스트 구조: 데이터 필드, 링크 필드
7. 연결리스트에서 새 노드 삽입 시 while로 ptr!=null일 때 next옮기고 before를 갱신하면서 before로 연결

[찜찜]
1. 합병 정렬은 배열 하나 새로 파서 left~ mid+1~비교하면서 넣고, 남은거 있으면 털고 기존 배열에 옮기기
void merge(int a[], int left, int mid, int right){
    int i=left, j=mid+1, k=left, h;
    int tlist[MAX_SIZE];

    while(i<=mid && j<=right){
        if(a[i]<=a[j]){
            tlist[k]=a[i];
            i++;
            k++;
        } else {
            tlist[j]=a[j];
            j++;
            k++;
        }
    }

    if(i>mid)
	while(j<=right)
	    tlist[k++]=a[j++];
    else
	while(i<=mid)
	    tlist[k++]=a[i++];

    for(h=left; h<=right; h++)
	a[h]=tlist[h];
}


void merge_sort(int a[], int left, int right){
    int mid;
    if(left<right){
        mid=(left+right)/2;
        merge_sort(a, left, mid);
        merge_sort(a, mid+1, right);
        merge(a, left, mid, right);
    }
}

2. 삽입정렬은 1부터 시작하는 기준점이 들어갈 위치를 그 좌측부터 찾는 배열로, j=i-1가 i데이터보다 크다면 어차피 더 내려가야 i가 들어갈 곳을 찾기에 a[j+1]=a[j]로 shift해버리고 j--. 나중에 루프 끝나면 a[j+1]=idata;를 수행. j는 i보다 작은 값일테니 하나 더해서.
void insertion(int a[], int n){
    int i, j, idata;
    for(i=1; i<=n-1; i++){
	idata=a[i];
	j=i-1;
	while(a[j]>idata && j<=0){
	    a[j+1]=a[j];
	    j--;
	}
	a[j+1]=idata;
    }
}













